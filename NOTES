

probe name

sort formats somehow? determistics

path() function
some reflection? foramts? input file name etc?
raw -> bits? slice?
hexdump function?
rename text to dump? depth args?
tests runs jq queries? asset stdoutish? base64 for bin?

verbose/derails flag?

warnings []error somehow?

bindings in gojq? use for test?

test syntax:
0b1011
0x34
adad


decode part of file?

force decode part of file with decoder?

error in sub decoder position not absolute

jq value with out _value? how?

jq script to summarise?

# mp4 track codecs
[.. | select(.type._value? == "stsd") | .reference[].type._value]
# apic picture data
.. | select(.id._value == "APIC") | .picture._raw
# sidx dump
.. | select(.type._value=="sidx") | .index_table | [.[] | {size: .size._value, duration: .duration._value}]
# what field is at bit position x?
.. | select(._type == "field" and ._range.start <= x and x < ._range.stop)
#
'.frame[] | [.end_of_header.frame_number._value, ._size] | join(" ")') | gnuplot -p

decode and fill gaps if known size?

bitio MultiReader

deocde own bitio.Buffer api that panics?

gojq time?

encofing format? endian some name?

text: when color fill with all bytes but dark?

DONE FieldValidateString -> FieldValidateUTF8/Bytes?

text: show parents when selectin deep down?

DONE text: off by one

mp4: aac adts? ASC

DONE RangeGaps: only range args

unknow does not handle nested bitbufs

add panic if manual "unknown" is added?

warnings list, show only mode? unknown section marked with warning?

mulitple file args, make array?

DONE indent address for ntested bifbufs in text viewer?

DONE add field name to panics?

warnings? like zero padding or skip junk after id3v2?

DONE register in reverese order? override? ogg demuxer should deocde using "ogg_packet" group? reverse enalbed override?


array in array

DONE float/fp endian? default?

DONE go generate -x ./...

DONE replace Groups by Names "jpeg", format.IMAGE



go build -gcflags="-d=ssa/check_bce/debug=1" boundscheck.go 
readbits:
_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808


end at is one off?

register groups, images, all? dont allow decode without list?

lazy decode?

explicit sub section function?
split value / multi function?

show gaps


If if know size of files... hint that it's outside?
0204cc30 bf fa 69 c0                                    |..i.            |      chunk_size: 3228170943 33868848-33868852 (4)
0204cc30             fe 95 95 fb 6b 3c fd 75 57 fa c3 ee|    ....k<.uW...|      data: none 33868852-3262039795 (3228170943)
0204cc40 fb 37 29 f9 fc 02 fd 8f ea f9 80 2d fe 18 e1 fa|.7)........-....|
*        3228170915 bytes more, ends at c26ec6f3



custome functions to help query by positoons etc?


align hexdump left mode?

show fields for position range? neg for from end?

make the "|   |" at the end correct

text BitBuf abs relative... byte values? detect not same as abs bitbuf?

text: zero length fields...

show fields at position?

DONE "more bytes" only if > byteLine?


errors in field tree?

bitio.Copy()?

Field/Range does not record field range?

MultiBitBuf reader?

error from sub decoder?

Copy -> Clone? reset pos?

decoder guide:
  invalid is no zero input, assert one valid frame etc
  try validate input to make it not ambiguous so that multple deocders could match
  split bit flags etc into a field with subfields for each bit
  try keep code as declarative as possible
  split into multiple sub decoders if possible


ogg.FileDecoder -> ogg.Page add segments blabl ause from ogg.FileDeocer?

gaps

bibuf for field? remove decoder?

demux add to first packet etc?

nBits < 0

context?

skip same lines in ascii/hexpairs?

fq bla.ogg '.page | size(.) '


flv

"script" api one .go for custom decoder?

uint64 -> int .. is 64bit anyway?

automcatically add gaps/unknown?

replace hexdumo with addresview, hexview, asciiview, treeview etc?

mp3: zero padding between id3v2 and mp3frame?
[mp3 @ 0x555556c46080] Skipping 10 bytes of junk at 53241.
/Users/wader/Downloads/original/b81c8b9b.mp3

AbsPos nested decoders? 

https://id3.org/Lyrics3v2 d/04.\ deru\ -\ echos\ of\ me.mp3eru

add field in parent or by ref somehow? ogg demuxer etc

standrize names mapping?

simplifixed, essential info?








                                                                               test.mp3: mp3 (audio/mpeg) 1103 0-1103 (1103) {
00000000  49 44 33 04 00 00 00 00  00 32 54 50 45 31 00 00  |ID3......2TPE1..|   header: id3v2 (application/x-binary) 60 0-60 (60) {
00000010  00 05 00 00 03 62 6c 61  00 54 53 53 45 00 00 00  |.....bla.TSSE...|     magic: Correct ("ID3") 0-3 (3)
00000020  0f 00 00 03 4c 61 76 66  35 38 2e 34 35 2e 31 30  |....Lavf58.45.10|     version: 4 3-4 (1)
00000030  30 00 00 00 00 00 00 00  00 00 00 00 ff fb 50 00  |0.............P.|     revision: 0 4-5 (1)
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|     flags: none 5-6 (1) {
                                                                                     unsynchronisation: 0 5-5+1 (0+1)
                                                                                     extended_header: false 5+1-5+2 (0+1)
                                                                                     experimental_indicator: 0 5+2-5+3 (0+1)
                                                                                     unused: 0 5+3-6 (0+5)
                                                                                   }
                                                                                   size: 50 6-10 (4)
                                                                                   TPE1: Lead performer(s)/Soloist(s) ("TPE1") 10-25 (15) {
                                                                                     id: "TPE1" 10-14 (4)
                                                                                     size: 5 14-18 (4)
                                                                                     flags: none 18-20 (2) {
                                                                                       unused: 0 18-19+6 (1+6)
                                                                                       unsync: false 19+6-19+7 (0+1)
                                                                                       data_length_indicator: false 19+7-20 (0+1)
                                                                                     }
                                                                                     text_encoding: UTF-8 (3) 20-21 (1)
                                                                                     text: "bla" 21-25 (4)
                                                                                   }
                                                                                   TSSE: Software/Hardware and settings used for encoding ("TSSE") 25-50 (25) {
                                                                                     id: "TSSE" 25-29 (4)
                                                                                     size: 15 29-33 (4)
                                                                                     flags: none 33-35 (2) {
                                                                                       unused: 0 33-34+6 (1+6)
                                                                                       unsync: false 34+6-34+7 (0+1)
                                                                                       data_length_indicator: false 34+7-35 (0+1)
                                                                                     }
                                                                                     text_encoding: UTF-8 (3) 35-36 (1)
                                                                                     text: "Lavf58.45.100" 36-50 (14)
                                                                                   }
                                                                                   padding: Correct (padding) 50-60 (10)
                                                                                 }




DONE move cli thigns to package
DONE move deocde to not internal to have own decoders

path exp
child[0]
child[field=...]
[0]
[field=ad]
child[-1]
field~=a.*
field=\x00...


all outputs:
raw:
value:
json:
text:

tree()
@value 



FieldDecoder -> FieldDecoder


whole file hash?

FieldTryDecode?

Probe take name and figure out range?



Field
    Value
        Decoder


Decoder
    RootField
        Value
            Decoder




DecoderRegister {
    All:
    Allowed
}

range map to/from aprents? demuxers etc?

d.End ...also d.HasBifsLeft etc?

vistuluze decode relations? import paths?

d.Decode()
d.DecodeLen()
d.FieldDecode()
d.FieldDecodeLen()  .. unknown if fail

d.FieldValiateDecode()


ffmpeg -y -f lavfi -i sine -t 20ms -ac 2 -ar 44100 -metadata artist=bla test.ogg
ffmpeg -y -f lavfi -i sine -f lavfi -i testsrc -t 100ms -ac 2 -ar 44100 -metadata artist=bla test2.ogg

FieldBytesFn that uses start-stop pos to get bytes? maybe just a ui thing?


json
sql
api?

uniq paths?


auto probe sub data? mime not really needed?

bit pos

jpeg display and decode?

demuxing somehow?


web inteface?


parser args? have "lisp" parser taking script path as arg?


field without size?

FieldValue function?

refence type? goto poisioint? sample table etc?

float/double

time?

protobuf

zigzag


FieldUCompare?


Verify func set error?
Value, error field?

FieldVerifyFn -> FieldVerifyUFn ??


sub decode

demux stream?


BitBuf
BitBuf.BitBuf(213)


options, probe, force parse?

probe tool... unify media info fields? sample_rate blabla...




DONE mp3frame -> mp3_frame?
DONE tar.gz nested.. 
DONE field have a decoder value?
probe skip some? if not force?

ogg -> oggpage, vorbisframe?
buffer... list of ranges maps?

init register in All? ok? sort to be stable?

decode dont embedd? reimplement api with panics

bitreader
    return error
field dsl
    bitreader err => panic(err)? recover?
    valid check err => painc(err) if not force?
    recover?



var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to `file`")
var memprofile = flag.String("memprofile", "", "write memory profile to `file`")


	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		defer f.Close() // error handling omitted for example
		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
		defer pprof.StopCPUProfile()
	}

	// ... rest of the program ...

	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			log.Fatal("could not create memory profile: ", err)
		}
		defer f.Close() // error handling omitted for example
		runtime.GC()    // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			log.Fatal("could not write memory profile: ", err)
		}
	}


