

2021/01/11 22:12:45 r: "break"
inputs[1] [.]> 999000000000000 / 3
2021/01/11 22:12:50 l: 999000000000000
2021/01/11 22:12:50 r: 3
333000000000000
2021/01/11 22:12:50 l: "break"
2021/01/11 22:12:50 r: "break"
inputs[1] [.]> 182812892749652077953760942202754471806 / 255
2021/01/11 22:12:53 l: +182812892749652077953760942202754471806
2021/01/11 22:12:53 r: 255
2021/01/11 22:12:53 BLA1
716913304900596400000000000000000000
2021/01/11 22:12:53 l: "break"


... | repeat(flac_frame)


.frames[-20:-0][].block_size : panic

[.frames[-16:][] | (.end_of_header.block_size._value // .block_size._value)] | add

hex, binary, 

ffmpeg -f lavfi -i sine -ac 2 -c:a flac -strict experimental -f mp4 -t 50ms flac.mp4


own FqInterace? function ineterface?


repl in jq, expose parse/run?

go run cmd/fq/main.go -n - '["digraph formats {"] + [[formats[] | . as $f | .dependencies | flatten? | .[] | [$f.name, .]] + [formats[] | . as $f | .groups | flatten? | .[] | [., $f.name]] | .[] | join(" -> ")] + ["}"] | join("\n")' | dot -Tsvg -o formats.svg

replace dot function with jq to dot formatting somehow?

Run should know if autocompleting? dont allow open() etc

refactor query.go to be more modular

summary count uniq paths only count arrays

nested buf... struct nested ranges "leak out" to parent.. for example zero

DONE reomve {} i dump for struct

// TODO: addr|hh h hh hh  hh hh hh hh  hh hh hh hh hh|aaaa aaaa aaaa aaaa

d.Panic?

DONE pluralize array/struct thingy

zero file test


go run cmd/fq/main.go flac.mkv '"fLaC", (.. | select(._name == "metadatablock" and ._type == "struct")), (.. | select(.packet._description=="flac_frame" ) | .packet) | bits' > bla.flac
go run cmd/fq/main.go flac.mp4 '"fLaC", (.. | select(._name == "metadatablock" and ._type == "struct")), .tracks[0].samples[] | bits' > bla.flac

dump support other things than value? "asdsd" | d ? nice when messing around


progress estimate, have a 1024 buckets for whole file and mark truncated pos as going along? count += 1 if flag not set before?


Decode... descriptin gone

flac md5 fix

move more fields things into value.go?

checksum, update existing... hard when split between decoders, *decode.D can't be passed around becuse offset wrong

SafeDecodeFn logs to stderr

| bits, support numbers and list as bytes? iolistish?

settings via object? global s({verbose: true), verbose(true) ? 

DONE spu signal end?

DONE select assign crahes...
DONE %!s(PANIC=Error method: invalid value: struct)

sub decoder doing seek at end but no more reads... probe will ignore it as part of length, offset wrong how to fix

decodeLen should fill gaps somehow? deferred?


refacotr run to make it possible to run steps? fixes iterator thingy?

-i without input?

dump options? how? verbose? global per call?

hexdump absolute buf address? same as dump?

rename dump? tree? summary? show?

with iter as value

| json?

solid lines in cli? printf "\x1b(0\x78\x1b(B" if LANG LC_ALL? only if -u or so? pipe /copypaste?
\xe2\x94\x82


show details in Path()? struct name etc?

... | default

... | push?

pop

u1,u2,s1le etce tc?

dot value is a stack etc? cd/cd ..? pop/push?

dump no recursive bit bufs option? no resuvei decoders?

mkv crc

can't use range while decoding not calucalted yet

fix errors and warnings

nested bitbuf

jq hex bin

encoding used

show name in dump? how?!

rename dump?

hexdump use own, matches dump hexumpd

outout separate with something? path?

root show full path?

mustio.Copy?

error tests
- unknown format
- other errors
- ._value string hexdump test (unexpected eof weirdness)

REPL? reuse probe output in variable?

io.Copy variant that panic? NoErrCopy helper? for crc etc

read file function?
diff function?

DONE d.FieldRemove?

tests, unscape into list of bitio.buffers etc? multi bit reader?

jq functions to conmfigre depth etc? wrapper structs?

synthentic fields somehow? with range to positon?


DONE FieldCRC -> FieldChecksum

DONE bits(statr; len)

range, byte_range?


validate should only add warning if fail?

FieldAssert?

FieldBytesFn hmm clean up readers?
Replace Value function? maybe nice when doing non-liner decode? FieldValueBytes mess

ffmpeg -y -f lavfi -i testsrc -f lavfi -i sine -ac 2 -c:a libvorbis -t 5s test.webm

DONE pretty print json


var args to encoding and description?
format descriptions

subdecode.. positison wrong in error etc

fillgaps when decoding know range? subdecode etc?

nice decode dsl?

skip probe how? -f raw? . is  bitbuf field with name?

#!/bin/fq -r
blabla
pass jq deocde value into jq quert again

pass in context somehow? break in reader?

funciton better wrong value error message

probe name

better error, wrap panics to passhtur bug panics?

sort formats somehow? determistics

path() function
some reflection? foramts? input file name etc?
DONE raw -> bits? slice?
DONE hexdump function?
DONE rename text to dump? depth args?
tests runs jq queries? asset stdoutish? base64 for bin?

verbose/derails flag?

warnings []error somehow?

bindings in gojq? use for test?

test syntax:
0b1011
0x34
adad


decode part of file?

force decode part of file with decoder?

error in sub decoder position not absolute

jq value with out _value? how?

jq script to summarise?

# mp4 track codecs
[.. | select(.type._value? == "stsd") | .reference[].type._value]
# apic picture data
.. | select(.id._value == "APIC") | .picture._raw
# sidx dump
.. | select(.type._value=="sidx") | .index_table | [.[] | {size: .size._value, duration: .duration._value}]
# what field is at bit position x?
.. | select(._type == "field" and ._range.start <= x and x < ._range.stop)
#
(echo -e "set term svg\nset output 'test.svg'\nplot '-'"; go run cmd/fq/main.go test.flac 'probe | .frame[] | [.end_of_header.frame_number._value, ._size] | join(" ")') | gnuplot

# mkv metadata tags
'[.. | select(.id._symbol == "Tags") | .. | select(.id._symbol == "SimpleTag") | {(.element[0].value._value): (.element[1].value._value)}] | add'

decode and fill gaps if known size?

bitio MultiReader

deocde own bitio.Buffer api that panics?

gojq time?

encofing format? endian some name?

text: when color fill with all bytes but dark?

DONE FieldValidateString -> FieldValidateUTF8/Bytes?

text: show parents when selectin deep down?

DONE text: off by one

mp4: aac adts? ASC

DONE RangeGaps: only range args

unknow does not handle nested bitbufs

add panic if manual "unknown" is added?

warnings list, show only mode? unknown section marked with warning?

mulitple file args, make array?

DONE indent address for ntested bifbufs in text viewer?

DONE add field name to panics?

warnings? like zero padding or skip junk after id3v2?

DONE register in reverese order? override? ogg demuxer should deocde using "ogg_packet" group? reverse enalbed override?


array in array

DONE float/fp endian? default?

DONE go generate -x ./...

DONE replace Groups by Names "jpeg", format.IMAGE



go build -gcflags="-d=ssa/check_bce/debug=1" boundscheck.go 
readbits:
_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808


end at is one off?

register groups, images, all? dont allow decode without list?

lazy decode?

explicit sub section function?
split value / multi function?

show gaps


If if know size of files... hint that it's outside?
0204cc30 bf fa 69 c0                                    |..i.            |      chunk_size: 3228170943 33868848-33868852 (4)
0204cc30             fe 95 95 fb 6b 3c fd 75 57 fa c3 ee|    ....k<.uW...|      data: none 33868852-3262039795 (3228170943)
0204cc40 fb 37 29 f9 fc 02 fd 8f ea f9 80 2d fe 18 e1 fa|.7)........-....|
*        3228170915 bytes more, ends at c26ec6f3



custome functions to help query by positoons etc?


align hexdump left mode?

show fields for position range? neg for from end?

make the "|   |" at the end correct

text BitBuf abs relative... byte values? detect not same as abs bitbuf?

text: zero length fields...

show fields at position?

DONE "more bytes" only if > byteLine?


errors in field tree?

bitio.Copy()?

Field/Range does not record field range?

MultiBitBuf reader?

error from sub decoder?

Copy -> Clone? reset pos?

decoder guide:
  invalid on zero length inputer, assert one valid frame etc
  try validate input to make it not ambiguous with other decoders
  try to not seek and read at end while validating or early, will break progress incidate if not
  split bit flags etc into a field with subfields for each bit
  try keep code as declarative as possible
  split into multiple sub decoders if possible


ogg.FileDecoder -> ogg.Page add segments blabl ause from ogg.FileDeocer?

gaps

bibuf for field? remove decoder?

demux add to first packet etc?

nBits < 0

context?

skip same lines in ascii/hexpairs?

fq bla.ogg '.page | size(.) '


flv

"script" api one .go for custom decoder?

uint64 -> int .. is 64bit anyway?

automcatically add gaps/unknown?

replace hexdumo with addresview, hexview, asciiview, treeview etc?

mp3: zero padding between id3v2 and mp3frame?
[mp3 @ 0x555556c46080] Skipping 10 bytes of junk at 53241.
/Users/wader/Downloads/original/b81c8b9b.mp3

AbsPos nested decoders? 

https://id3.org/Lyrics3v2 d/04.\ deru\ -\ echos\ of\ me.mp3eru

add field in parent or by ref somehow? ogg demuxer etc

standrize names mapping?

simplifixed, essential info?








                                                                               test.mp3: mp3 (audio/mpeg) 1103 0-1103 (1103) {
00000000  49 44 33 04 00 00 00 00  00 32 54 50 45 31 00 00  |ID3......2TPE1..|   header: id3v2 (application/x-binary) 60 0-60 (60) {
00000010  00 05 00 00 03 62 6c 61  00 54 53 53 45 00 00 00  |.....bla.TSSE...|     magic: Correct ("ID3") 0-3 (3)
00000020  0f 00 00 03 4c 61 76 66  35 38 2e 34 35 2e 31 30  |....Lavf58.45.10|     version: 4 3-4 (1)
00000030  30 00 00 00 00 00 00 00  00 00 00 00 ff fb 50 00  |0.............P.|     revision: 0 4-5 (1)
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|     flags: none 5-6 (1) {
                                                                                     unsynchronisation: 0 5-5+1 (0+1)
                                                                                     extended_header: false 5+1-5+2 (0+1)
                                                                                     experimental_indicator: 0 5+2-5+3 (0+1)
                                                                                     unused: 0 5+3-6 (0+5)
                                                                                   }
                                                                                   size: 50 6-10 (4)
                                                                                   TPE1: Lead performer(s)/Soloist(s) ("TPE1") 10-25 (15) {
                                                                                     id: "TPE1" 10-14 (4)
                                                                                     size: 5 14-18 (4)
                                                                                     flags: none 18-20 (2) {
                                                                                       unused: 0 18-19+6 (1+6)
                                                                                       unsync: false 19+6-19+7 (0+1)
                                                                                       data_length_indicator: false 19+7-20 (0+1)
                                                                                     }
                                                                                     text_encoding: UTF-8 (3) 20-21 (1)
                                                                                     text: "bla" 21-25 (4)
                                                                                   }
                                                                                   TSSE: Software/Hardware and settings used for encoding ("TSSE") 25-50 (25) {
                                                                                     id: "TSSE" 25-29 (4)
                                                                                     size: 15 29-33 (4)
                                                                                     flags: none 33-35 (2) {
                                                                                       unused: 0 33-34+6 (1+6)
                                                                                       unsync: false 34+6-34+7 (0+1)
                                                                                       data_length_indicator: false 34+7-35 (0+1)
                                                                                     }
                                                                                     text_encoding: UTF-8 (3) 35-36 (1)
                                                                                     text: "Lavf58.45.100" 36-50 (14)
                                                                                   }
                                                                                   padding: Correct (padding) 50-60 (10)
                                                                                 }




DONE move cli thigns to package
DONE move deocde to not internal to have own decoders

path exp
child[0]
child[field=...]
[0]
[field=ad]
child[-1]
field~=a.*
field=\x00...


all outputs:
raw:
value:
json:
text:

tree()
@value 



FieldDecoder -> FieldDecoder


whole file hash?

FieldTryDecode?

Probe take name and figure out range?



Field
    Value
        Decoder


Decoder
    RootField
        Value
            Decoder




DecoderRegister {
    All:
    Allowed
}

range map to/from aprents? demuxers etc?

d.End ...also d.HasBifsLeft etc?

vistuluze decode relations? import paths?

d.Decode()
d.DecodeLen()
d.FieldDecode()
d.FieldDecodeLen()  .. unknown if fail

d.FieldValiateDecode()


ffmpeg -y -f lavfi -i sine -t 20ms -ac 2 -ar 44100 -metadata artist=bla test.ogg
ffmpeg -y -f lavfi -i sine -f lavfi -i testsrc -t 100ms -ac 2 -ar 44100 -metadata artist=bla test2.ogg

FieldBytesFn that uses start-stop pos to get bytes? maybe just a ui thing?


json
sql
api?

uniq paths?


auto probe sub data? mime not really needed?

bit pos

jpeg display and decode?

demuxing somehow?


web inteface?


parser args? have "lisp" parser taking script path as arg?


field without size?

FieldValue function?

refence type? goto poisioint? sample table etc?

float/double

time?

protobuf

zigzag


FieldUCompare?


Verify func set error?
Value, error field?

FieldVerifyFn -> FieldVerifyUFn ??


sub decode

demux stream?


BitBuf
BitBuf.BitBuf(213)


options, probe, force parse?

probe tool... unify media info fields? sample_rate blabla...




DONE mp3frame -> mp3_frame?
DONE tar.gz nested.. 
DONE field have a decoder value?
probe skip some? if not force?

ogg -> oggpage, vorbisframe?
buffer... list of ranges maps?

init register in All? ok? sort to be stable?

decode dont embedd? reimplement api with panics

bitreader
    return error
field dsl
    bitreader err => panic(err)? recover?
    valid check err => painc(err) if not force?
    recover?



var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to `file`")
var memprofile = flag.String("memprofile", "", "write memory profile to `file`")


	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		defer f.Close() // error handling omitted for example
		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
		defer pprof.StopCPUProfile()
	}

	// ... rest of the program ...

	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			log.Fatal("could not create memory profile: ", err)
		}
		defer f.Close() // error handling omitted for example
		runtime.GC()    // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			log.Fatal("could not write memory profile: ", err)
		}
	}


